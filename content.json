{"pages":[],"posts":[{"title":"CS:APP II 番外-switch 的指令实现","text":"看起来上一篇 post 写的又长又严肃，主要也是因为章节内容的特点。这几节的内容是 Machine Level Programing，可以自己捣鼓的东西多了，就分出许多个小的部分来写写。 switch 语句作为 control flow 的一部分，在底层实现上比单纯 if-then-else 要复杂一点，编译器对于形式不同的 switch 语句实现了不同的优化来达到最高效率。 下面所有的实验都是在 Ubuntu x86-64 环境下进行的，编译指令是： 1$ gcc -Og -S &lt;SourceFileName&gt; -o &lt;TargetProgramFileName&gt; 3 个数值123456789101112131415161718#include &lt;stdio.h&gt;int main(){ int command; scanf(\"%d\", &amp;command); switch(command){ case 0: printf(\"0\\n\"); break; case 1: printf(\"1\\n\"); break; case 2: printf(\"2\\n\"); break; } return 0;} 我们可以看到，在这种 cases 数量较少的情况下， switch 语句被当作了几个不同的 if 语句来进行处理。 5 个数值123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(){ int command; scanf(\"%d\", &amp;command); switch(command){ case 0: printf(\"0\\n\"); break; case 1: printf(\"1\\n\"); break; case 2: printf(\"2\\n\"); break; case 3: printf(\"3\\n\"); break; case 4: printf(\"4\\n\"); break; } return 0;} 关于具体的汇编代码，有几个细节： Q：为什么看起来只判断了 command 参数大于 4 的情况，小于零的情况怎么办？ A：这里的 ja 指令进行的是无符号数的大小比较，根据前面讲过的补码表示法，有符号的负数被解释为无符号数的时候，就是大于 INT_MAX 的数，自然可以被排除掉。啊，再一次体会到了编译器的强大，要是我自己去写汇编，怕是一辈子也想不到。 Q：地址计算的过程到底干了些什么？ A：首先我们看到 lea 0xe50(%rip),rdx 这一行，首先， %rdx 被赋值了一个地址，这里出现了一个 “较大” 的运行前常量，显然这是编译器有意计算出来的，作为 “存储 cases 对应指令地址的数组的地址”。 不过通过下面 add %rdx,%rax 这条指令来看，这个地址并不是完整的地址，只是一个偏置量。在加过 %rax 后，就得到了真正的这个 case 对应的指令的地址。 Q：64 字长的机器的虚拟内存的地址应该是一个 64 位整数（或者至少 48 位），占 8 个字节啊，为什么这里在访问数组的时候用到的 scaler 是 4 字节的？ A：还是和上面提到的一样，这个数组里面存放的数据只是地址偏置量，不是完整的地址，加过 %rax 后才是真正的地址。 编译器生成了一个地址跳转表，分别对应每一个 case 对应的该执行的指令的地址，通过这一系列乍一看起来非常奇怪的寻址计算，直接 jump 到这了该执行的位置，这使得 switch 语句的整体复杂度降低到了 $O(1)$。 密集但不连续123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;int main(){ int command; scanf(\"%d\", &amp;command); switch(command){ case 0: printf(\"0\\n\"); break; case 1: printf(\"1\\n\"); break; case 2: printf(\"2\\n\"); break; case 3: printf(\"3\\n\"); break; case 4: printf(\"4\\n\"); break; /* * No case 5 and case 6 */ case 7: printf(\"4\\n\"); break; case 8: printf(\"4\\n\"); break; case 9: printf(\"4\\n\"); break; default: printf(\"default\\n\"); break; } return 0;} 这里的 C 代码中漏过了 command 参数等于 5 或者 6 的情况，多了 default 的情况。 直接从汇编里面看，没有了 je （这是自然），其它的 cases 的情况还是一个从数组中读地址的过程，那么如果碰到 command = 5 这种情况呢，我们来查看一下跳转表。 可以看到，编译器对于 case 5 和 case 6 的情况，对应的跳转位置（的值）要比其它的都要大一点点，从最终的汇编代码上看，确实 default 对应的指令在 main 函数的最末尾。 总结：如果出现间断，但整体连续的情况，编译器仍然会生成跳转表，只是让中间错过的部分跳转到 default 或者 switch 的结尾。 离散数值看到这里相信读者会有一个自然的疑问，既然 case 的值是任意的，如果出现一个非常大的数值，那么再生成一个地址跳转表将会浪费巨额的空间，编译器自然不会这样去选择，那么这时的实现方法是什么呢？ 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int main(){ int command; scanf(\"%d\", &amp;command); switch(command){ case 0: printf(\"0\\n\"); break; case 1: printf(\"1\\n\"); break; case 2: printf(\"2\\n\"); break; case 100: printf(\"4\\n\"); break; case 2020: printf(\"4\\n\"); break; case 1000000: printf(\"1000000\\n\"); break; } return 0;} 读这个的汇编代码可能会有点困难…还是直接讲解演示吧。 编译器会根据给定的 cases 的值，构建一棵平衡二叉搜索树（静态的，不用修改），每一个节点对应一个 if branch ，这样可以支持在 $O(logN)$ 的时间内找到对应的分支，同样比直接顺序查找的 $O(N)$ 效率高。","link":"/2020/02/06/CSAPP%20II%20switch/"},{"title":"Five Dialogues - Apology","text":"&emsp;&emsp;翻译了一下 Plato, Five_Dialogues 中 Apology 的几页。 $$\\huge\\textbf{辩护}$$ &emsp;&emsp;$辩护$ [^1]被认为是苏格拉底在他自己的审讯中进行的辩护的记录。这种说法使其历史性的问题比其它的”对话“更加尖锐，其它”对话“大多是虚构的，而关于它们的历史性的问题仅仅只关于苏格拉底提出的理论与历史上的苏格拉底的距离。但是，在这里，我们正在看历史上真正的的苏格拉底发表的讲话。柏拉图记录的精确度有多高呢？我们应该永远记住，古人不像我们一样在意历史的准确性。另一方面，柏拉图清晰地表明了他参加了这场审讯$（34a, 38b）$。而且，如果像一般认为地那样，这篇文章是在审讯后不久写的，那么许多雅典人就会记住实际的讲话，如果柏拉图在书中修改实际讲话内容，无疑是一种为老师辩白的很差的方式。些许的更改无疑是可以的，但是主要的论点和整体的语气一定是忠于事实的。语言和风格的美当然是柏拉图的，但性格中宁静的精神和道德美属于苏格拉底。这是一个强大的组合。 &emsp;&emsp;雅典的陪审团很大，在这次审判中是 501 人，他们通过定罪和量刑将陪审团和法官的职责结合在一起。显然，如此庞大的机构几乎不可能讨论各种处罚并作出决定。然而，这个问题被相当巧妙地解决了，在定罪之后，让检察官评估他认为适当的刑罚，然后由被告进行反评估。然后，陪审团将在两者之间做出决定。通常，此过程在双方上都是适度的。因此，$辩护$一文共分成三个部分，第一部分，同时也是主要部分，是主要讲话$（17a-35d）$，然后是反评估$（35e-38b）$，最后，对陪审团的遗言，既对投给他死刑的，也对投给他无罪的。$$G.M.A.G$$ &emsp;&emsp;我不知道，雅典的人们[^2]，我的指控者如何影响了你。他们的话如此有说服力，即使是我，也几乎忘乎其中。然而，他们所说的话几乎没有什么是真的。他们讲的诸多谎言中，其中一个让我特别惊讶的是：“要小心，不要被像我（苏格拉底）这样成功的演讲者所欺骗”。当我证明自己根本不是一个成功的演讲者时，他们并不感到羞耻，我认为最无耻的是他们，除非确实他们称一个有成就的演讲者为讲真话的人。如果他们是这个意思，那么我会同意我是一名雄辩家，但不是按照他们的方式行事，因为正如我所说，的确他们所说的几乎没有什么是真的。从我这里，您会听到全部的真相，尽管不是宙斯，用像他们那样的优美语句所说，而是我是随意地，用直接涌入我脑海的词句来说的，因为我相信我所说的话是正义的，不会让你们有其它感受。我这样年纪的人出现在你面前时，像一个年轻人那样言语玩弄是不合适的。 &emsp;&emsp;先生们，有一件事我请求你们：如果我的辩护的口吻就像我平日里在存钱柜台边的市场[^3]，那里也是你们很多人听说我的地方，请不要感到惊讶，也不要打扰他们的柜台。事情是这样的：这是我七十年来第一次上法庭。 因此，我只是对这里的讲话方式感到陌生。 就像，如果我真的是一个陌生人，我说我年少时候的方言，您一定会原谅我，所以我现在的要求也只是一个要求，因为您不必理会我的举止，无论是好是坏，但要集中注意力于我所说的话是否公正，因为一个法官的卓越之处就在于此，而演讲者的卓越之处在于讲真话。 [^1]: “Apology” 一词是对希腊词 “apologia” 的音译，而不是翻译，这意味着辩护。 演讲当然没有道歉。[^2]: 雅典从所有30岁以上的男性公民中抽签选出陪审员，他们在当天履行职务。 他们因此充当雅典人民和雅典民主的代表。 在诸如苏格拉底之类的案件中，他们代表整个公民团体判断被告的行为是否损害了他们的利益。 因此，苏格拉底可以像对待整个雅典人民一样向他们讲话，尤其是民主的游击派反对其寡头政治的反对者（例如，参见21a，32d）。 苏格拉底称陪审团为“雅典人”，而不是采用通常的称呼为“陪审员先生”（如 Meletus 在 26d 时所做的那样）。 他在 40a 时解释说，只有那些投票赞成无罪释放他的人才应该获得这一荣誉。[^3]: 在市场里有银行主或者换钱的人设置的柜台，这似乎是一个常传流言的地方。","link":"/2020/02/14/%E6%9F%8F%E6%8B%89%E5%9B%BE-%E4%BA%94%E6%AE%B5%E5%AF%B9%E8%AF%9D-%E9%80%89%E6%AE%B5%E7%BF%BB%E8%AF%91/"},{"title":"新的起点","text":"&emsp;&emsp;啊，就像做梦一样，就这样加入了联创 lab 组。 &emsp;&emsp;来华科也算挺久了，最开始对联创，对团队的印象开始于“华科转专业交流群”。那个时候还是八月份吧，都没有到学校报到。我记得是李子喻学长（来自光电校交，一直在转专业群里面积极地回答我们的问题，非常感激他的帮助），在群里面 post 了联创招新 FAQ 群二维码，当时我加入的时候大概就是一百人左右吧，后面涨到了 500+。学长当时顺带着还说了，“有 OI 基础的可以试试联创，没有的话就不用抱什么希望了”，知道这个的时候我还在暗自窃喜，想着以我的编程水平，应该还是很有机会的。 &emsp;&emsp;大概就是这个时候吧，非常渴望能加入团队，不过当时的主要矛盾是自己转专业的问题，这个属实是难搞，高考就考那么点破烂分数，高提档线 1 分，顺利地被调剂到医学，还是五年制，四年同济，这个问题就已经足够我头大了，不过这也怪不得谁，按北京这个冲学校的报法，高中算上我一共 6 位小伙伴，考前都是信誓旦旦地说要学计算机，最终没有一个直接进入真正的科班（btw，确有一位怕被调剂，报了略低的学校，进入了北京科技大学理科实验班，可以在大三自由选专业，现在正在接受残酷的数理化基础训练），其它的 2 电信、1 网安， 1 车辆。对我来说，似乎这个形式还要更严峻一点（ &emsp;&emsp;当时的我问学长：“考进启明和进团队哪个难啊？”，得到的回答是，进团队比考启明难多了，但是当时的我对这些难度并没有什么概念，心中的想法就是： 启明，数学，北京卷，GG； 校交，微积分，中值定理之前，抓紧时间； 团队，编程，OI，机会很大； &emsp;&emsp;后面的事情，也是大大地超出了我的预期。启明考试不但通过，还是前几名的高分通过，兴高采烈地进入了实验班，后面越上越发现自己上当了；校交没机会考，暑假学了很久的微积分倒是让我考试拿了两次启明卷第一；团队的测试彻底崩穿，到这一步才发现，大佬们的实力到底比我高了多少，我只是一个走不出舒适区，而舒适区又那么低端那么 low 的乐色。 &emsp;&emsp;然后就是慢慢的学习，慢慢地准备新一轮的团队招新，《鸟哥的 Linux 私房菜》《深入理解计算机系统》《计算机网络：自顶向下方法》，当时从一个闲鱼盗版商那里一口气买了这三本书，一本三十，就开始了自己的 Linux 学习之路，那时还是贪玩，课程这么少的时候都不认真学习，先是云顶之弈下棋，又是 LOL 打分，现在想起来自己真是离谱。 &emsp;&emsp;日子就这么一天天过，现在想来，自己确实是一直保持了个“要进团队”的雄心壮志，也确实有很多理由在推动着我：不想刷那些没用的课的加权，本科就业，互联网，还有更重要的，更广阔的计算机科学世界；不过现在想来，那时又为自己的目标真正付出了多少努力呢？大概，还是心里觉得自己差距太大，“即使不能成功也可以理解”，以现在一个“实现目标”后的视角来看，不过是为自己的懈怠找的借口罢了。 &emsp;&emsp;冰岩程序的学长从编程 0 基础开始，每天肝学习，也可以成为众人眼中的大佬。对我来说，那些曾经看起来遥不可及的差距，其实就是一次次地拓展能力边界，走出舒适区的过程积累出来的。就写算法题来说，这是我之前一直在做的事情，学习算法，少说是思考一下，做道题目；多说是学个新的，理解思想。再怎么强调算法的重要性都不为过，但算法始终只能是计算机世界的一小部分。做合格的，优秀的计算机学生（请允许我酸..），还得去做没做过的事情，了解更多的东西。以前害怕报错，用 IDE 只用菜单里面几个选项，能凑活就凑活，多一点也不懂；以前看不上“花哨”的语言，几乎完全不懂的情况下就瞧不起它们，这些都要逐渐地去改变，再去学习，再去进步。 &emsp;&emsp;今年情况特殊，春天的招新变成了春令营，从结果上看，这似乎也是对我的利好。兢兢业业地做任务，按部就班地跟着流程走，在这个过程中，确实想过，自己还挺有可能进入的，但从来没有把心踏实下来。短信到了之后，心情难以言表。兴奋有，开心有，又有一些紧张和焦虑。学长们给了我这个机会，那一刻是终点，又是一个起点。 “（请勿回复此短信）” 不用回复，也再也没有消息了，我就这样走完了这条路。 2 月 23 号：您当前的状态是成功提交报名表单，请关注手机短信及邮箱以便获取后续通知。 3 月 23 号：你通过了 2020 春季招新 lab 组群面审核流程，你已成功加入 lab 组。 这一个月，就这样过去啦！ &emsp;&emsp;和爸妈分享了这个消息，还有请教我 C 语言的同学，屈佬，我的室友们，他们和我一起开心，为我高兴。一直和他们分享着我的事情，有他们在我身边我感到特别幸福。 我说：“到时候联创就会发现他们上当了。” 他们说：“到时候何佬就发现自己上当了”。 （笑） 又要加油啦，数据结构大师，还有 zhuo1ang，总不能让大家觉得上了当吧~ (●’◡’●)","link":"/2020/03/23/%E6%96%B0%E7%9A%84%E8%B5%B7%E7%82%B9/"},{"title":"一个近期情况总结","text":"&emsp;&emsp;又是有一段时间没有在写博客了，不过这期间整体上还是没有把学业上的事情放的太松，一直在积极推 CS:APP 的进度。到写这篇博客的时候，刚刚完成了 Cache lab 的全部内容，也听完了这前面的所有 lecture，这也意味着正式完成了 Part I 的全部内容，撒花！虽然整体完成的不能说是非常顺利，但是还是学到了很多很多东西。回想一下，其实这四个 lab 最终的完美完成版里面都有别人的成果： Data lab 里面的 allOddBits，conditional，howManyBits，参考了他人的做法； Bomb lab 里面的 &lt;phase_6&gt; 大概有几个小的功能部分，其中我只看懂了前半部分，链表和排序参考了他人的分析； Attack lab，这个几乎可以算是完全个人完成的了，只有 Return Oriented Programming level 3 中，在卡住之后，看网络上的提示，注意到了 gadget farm 里面的 add_xy 函数，提供了最关键的偏移地址的功能； Cache lab，Part-B 里面的 64 * 64 矩阵转置的部分，自己只想清楚了为什么“裸 8 * 8 分块”是错误的，尝试 4 * 4 的分块得到了一半的分数，最后完全按照清华大佬的做法实现了最终方案，真的非常巧妙。 &emsp;&emsp;之前在别人的博客里面看到说这个 Cache lab 难度比前面的要高一些，当时还不是很了解这个 lab 到底是要做什么，感觉有一定的压力，毕竟前面几个 lab 做的不能说很漂亮。下载了 hand-out 之后，了解了大概的内容，当时就感觉前半部分似乎并不是很难啊，就是个 average-sized 模拟？弄了一个多小时就搞得差不多了，当时刚刚装了 Ubuntu 18.04 物理机，正要配置 VSCode 的开发环境，想要利用这个编辑器来调试一下程序，又碰到了 launch.JSON tasks.JSON 这两个东西，来回弄了两个多小时才明白各个配置信息是怎么用的，由于整个编译过程涉及到包含一个特殊的标准库，包含一个 CMU 提供的库，执行时要添加多个命令行参数，我这个 GCC + VSC 小白遇到了一大堆错误。等调好了回头再看，这其实都是再简单不过的几个选项设置了。 &emsp;&emsp;通过这件事情，其实也是反映了我个人捣鼓各类工具的能力非常之弱，一方面是自己总是不愿意走出舒适区，能凑活就凑活，需要一点配置（在熟悉的人眼中甚至不能算是任何程度的问题）、调试的工具、功能便不断躲避；另一方面，从过去的 OI 经历开始，我就是一个喜欢 “嘴巴 AC” 的选手，当时的我就常常不实际动手，而对于大学后的”ACM 与 工程项目”之争，还经常瞧不上，认为只是各种 ”调参“ ”调用库“ ”用别人封装的东西“。 &emsp;&emsp;现在回去再看，只是感觉到自己的幼稚与无知，其实各个方面的经验与积累都是非常难得的东西，从底层开始写一个”高并发低延迟“、健壮鲁棒的系统，和一个皮都不换、到处是虫的安卓 APK，要求的远远不是同样的能力，有无数过去的我、现在的我没听说过的技术、原理。 而对于大佬们来说，熟练地掌握工具、小技术的各种高级应用仅仅只是一个水到渠成，自然而然地过程，但对于我来说，仍然是要主动学习，主动探索的。 &emsp;&emsp;还有一个问题也是我在不断去想的。现在来到自动化专业，最直接的：汇编语言、离散数学、操作系统、体系结构、数据库、编译原理，这些重要的基础课程都不学，怎么样弥补这样的差距，虽然说永远不能成为科班的学生，在这个名头上和大家一致，不过能力上起码不能被落下太多…现在听上 15-213、CS 61A，也算是找到了一个很好的 go into CS 的方式，希望在后面我能完整地坚持下来，把每个 lab 做好，触碰那些教授们为我们设计的思维点。15-213 剩下的部分分别是系统，和网络，目前，计划着先把这些学完，就上手一些能做的项目，实现一些经典的算法、模型，大概就说这么多吧。","link":"/2020/02/24/%E7%BD%91%E8%AF%BE%E5%BC%80%E5%AD%A6%E5%90%8E%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"title":"CS:APP I 数据表示","text":"在 CSAPP 正式部分的第一章，作者重点向我们介绍了硬件层面的数据存储、处理的基本概念，整数、浮点数的编码规则，运算的规则与性质。 信息的表示方法在小时候浅薄地接触计算机世界的时候，有这样一个概念：“一切信息都是表示为二进制的”。具体来说，机器级程序本身就是一个字节序列，采用底层的、由二进制编码的指令集；而各类的数据，通过对应的编码规则，也由二进制表示。 计算机中，使用 8 个位（bit）的块，或者字节（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位。二进制程序将内存视作一个非常大的字节数组，成为虚拟内存（virtual memory）。内存的每个字节都由一个唯一的数字标识，称作它的地址（address）。 虚拟地址空间只是一个呈现给二进制程序的概念性映像，将物理内存在更高层级映射到虚拟内存的过程是将硬件和操作系统软件结合起来实现的。这一点提醒我们，平常谈到的内存往往指的是虚拟内存，它的完整功能并不是全部直接由硬件本身提供的。 字长每台计算机都有一个字长（word size），指明指针数据的标称大小（nominal size）。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。 具体来说，对于一台字长为 $w$ 位的机器而言，虚拟地址的范围就是 $0$ ~ $2^w-1$，程序最多访问 $2^w$ 个字节。 32位字长限制虚拟地址空间为 $4 GB$，拓展到 64 位字长使得虚拟地址空间为 $16 EB$，大约是 $1.84 * 10^{19}$ 字节。 C Data Type Typical 32-bit Typical 64-bit x86-64 char 1 1 1 short 2 2 2 int 4 4 4 long 4 8 8 float 4 4 4 double 8 8 8 pointer 4 8 8 上面的表给出了基本 C 数据类型所占的字节数的典型大小。 C 语言标准没有规定 int， long 等类型变量的字节数，这导致了一些程序可移植性的问题。为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，ISO C99 引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。其中有 int32_t，int64_t，它们分别为 4 个字节和 8个字节。 寻址与字节顺序：大小端对于占据多字节空间的程序对象，它在内存中的实际表示由两点所决定：这个对象的地址，以及这个对象在内存中的排列。 多字节的对象被存储为连续的字节序列，而对象的地址为其所使用的字节的最小的地址。例如，假设一个 int 类型的变量 x 的地址为 0x0100，那么 x 的四个字节将被存储在： 0x0100、0x0101、0x0102、0x0103 这四个连续的位置，这与我们一般的认识相符。 在连续的字节中排列表示一个对象的字节有两种通用的规则。考虑一个 $w$ 位的整数，假设 $w$ 是 8 的倍数，那么这些位就能被分组成为字节。把数据按照从最高字节到最低字节的顺序存储的方式叫做大端法（big endian）；而从最低字节到最高字节存储的方式叫做小端法（little endian）。 举例说明： 假设有 int 类型变量 x，位于地址 0x0100 处，它的 16 进制值位 0x01234567。地址范围 0x0100 ~ 0x0103的字节顺序依赖于机器的类型： 大端法 0x0100 0x0101 0x0102 0x0103 …… 01 23 45 67 …… 小端法 0x0100 0x0101 0x0102 0x0103 …… 67 45 23 01 …… 大多数 Intel 机器都只采用小端模式。 在 C 层级的编程中，大小端的特性几乎不会直接暴露给程序员，机器所使用的字节顺序是完全不可见的，可能与这一特点有关的有三种情况。 在网络数据传输时。 如果对不同机器的大小端特性不进行区分，数据信息的处理将发生错误。网络应用程序的代码编写必须遵守已经建立的，关于的字节顺序的规则，在数据发出前，数据接收后进行可能的转换。 直接阅读字节级别的整数数据时。 举例来说，从某个文件中摘除了下面这行代码，该文件给出了一个针对 Intel x86-64 处理器的机器级代码的文本表示： 4004d3: 01 05 43 0b 20 00 add %eax,0x200b43(%rip) 这一行是由反汇编器（disassembler）生成的。 这时，偏置量 D 的表示就是小端的。 编写规避正常的类型系统的程序时。 在 C 语言中，可以通过强制类型转换（cast）或联合（union）来允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。大多数应用编程都不推荐这种编码技巧，但是它们对系统及变成来说是非常有用，甚至是必须的。 12345678910111213141516171819202122#include &lt;stdio.h&gt;typedef unsigned char *byte_pointer;void show_bytes(byte_pointer start, size_t len){ size_t i; for (i = 0; i &lt; len; i++) printf(\" %.2x\", start[i]); printf(\"\\n\");}void show_int(int x){ show_bytes((byte_pointer) &amp;x, sizeof(int));}void show_float(float x){ show_bytes((byte_pointer) &amp;x, sizeof(float));}void show_pointer(void *x){ show_bytes((byte_pointer) &amp;x, sizeof(void *));} 函数 show_int，show_float 和 show_pointer 展示了如何分别输出类型为 int、float和 void * 的 C 程序对象的字节表示。可以观察到它门仅仅传递给 show_bytes 一个指向它们参数 x 的指针 &amp;x，且这个指针被强制类型转换为unsigned char *。这种强制类型转换告诉编译器，程序应该把这个指针看成一个指向“字节序列”，而不是原始数据类型的对象。 这些过程使用 C 语言的运算符 sizeof 来确定对象使用的字节数。一般来说，表达式 sizeof(T) 返回存储一个类型为 T 的对象所需要的字节数。使用 sizeof 而不是一个固定的值，是向编写在不同机器类型上可移植的代码迈进了一步。 移位运算C 语言提供了一种移位运算，向左或者向右移动位模式。 C 表达式 x &lt;&lt; k 会生成一个值：将 $x$ 向左移动 $k$ 位，丢弃掉最高的 $k$ 位，并在右端补 $k$ 个0。自然地，如果整数有 $w$ 个二进制位，那么移位量 $k$ 应该是一个 $0 ~ w-1$ 之间的值。移位运算还是从左至右可结合的，即： x &lt;&lt; j &lt;&lt; k 等价于 (x &lt;&lt; j) &lt;&lt; k 。 有左移运算，自然有与之对应的右移运算x &gt;&gt; k，但是机器支持两种方式的右移：逻辑右移和算术右移。 逻辑右移直接在左端补 $k$ 个 0，而算术右移在左端补 $k$ 个最高有效位的值。 算术右移的做法看起来有些奇特，但是它对于有符号整数的运算非常有用，下面是一个例子。 操作 值 参数 x [01100011] [10010101] x &lt;&lt; 4 [00110000] [01010000] x &gt;&gt; 4 (逻辑右移) [00000110] [00001001] x &gt;&gt; 4 (算术右移) [00000110] [11111001] C 语言没有规定对于有有符号数应该使用哪种类型的右移，但是几乎所有编译器/机器组合都对有符号数使用算术右移，且许多程序员都假设机器会使用这种右移。另一方面，对于无符号数，右移必须是逻辑的。 整数表示首先是无符号数的编码，假设一个整数数据类型有 $w$ 位，我们可以将位向量写成 $\\vec{x}$ ，表示整个向量。 对于向量 $\\vec{x}$ ：$$B2U_w(\\vec{x}) = \\sum_{i=0}^{w-1}x_i2^i$$无符号数的表示法是一个双射，$0 ~ 2^w-1$ 的共 $2^w$ 个整数都唯一地对应一个编码。 对于有有符号数的编码，共有方式：补码，反码，原码。绝大多数的计算机采用补码表示法（Two-complement)。在这个定义中，将最高位解释为负权。 对于向量 $\\vec{x}$ ：$$B2T_w(\\vec{x})=-x_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}{x_i2^i}$$补码表示法也是一个双射。 首先来分析补码表示法能表示的最大、最小，以及一些特殊值，以 $w=4$ 为例。 $$B2T_4([0000])=0_{10}$$ $$B2T_4([1000])=-1*2^{4-1}+0=-8_{10}$$ $$B2T_4([0111])=0+\\sum_{i=0}^{4-2}{2^i}=1+2+4=7_{10}$$ $$B2T_4([1111])=-8+1+2+4=-1_{10}$$ 每位均为 0，表示 0，这一点是自然的； 最高位为 1，其它位均为 0，表示最小值：$-2^{w-1}$； 最高位为 0，其它位均为 1，表示最大值：$2^{w-1}-1$； 每位均为1，表示 -1，加上一个正数溢出后从 0 开始重新记数，这也是自然的。 下面以一个例子再做说明： x = 15213: 00111011 01101101 y = -15213: 11000100 10010011 类型转换C 语言允许在各种不同类型之间进行显式或隐式的类型转换，从转换规则设计的角度，我们可以这样去思考：对于在两种形式中都能表示的数值，要求保持不变；另一方面，如果要这个数在新类型中无法表示，我们还需要设计一套规则。 考虑下面的代码： 123short int v = -12345;unsigned short uv = (unsigned short) v;printf(\"v = %d, uv = %u\\n\", v, uv); 在补码的机器上，上述代码会产生如下的输出： v = -12345, uv = 53191 我们看到，有无符号整数之间的强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。 浮点数浮点的意思是对形如 $V=x*2^y$ 的有理数进行编码，这是对于实数的一种近似表示。浮点数对执行非常大的数字、非常小（接近于 0）的数字，以及更普遍的作为实数运算的近似值的计算，是很有用的。 直到 20 世纪 80 年代，每个计算机制造商都设计了自己的浮点数标准，以及运算的细节。另外，它们不太关注运算的准确性，而把实现的速度和简便性看得更重要。 在 1985 年，这些情况随着 IEEE 754 标准的推出而改变了，这是一个设计精妙的表示浮点数及其运算的标准。目前，所有的计算机都支持后来这个被称为 IEEE 浮点的标准。 二进制小数类似十进制小数，考虑一个形如$$b_mb_{m-1}…b_1b_0.b_{-1}b_{-2}…b_{-(n-1)}b_{-n}$$的表示法，其中每一个位的取值范围是 $0$ 和 $1$。这种表示方法所表示的数定义如下：$$b=\\sum_{i=-n}^{m}{2^i*b_i}$$ 仅考虑有限位数的编码，那么十进制表示法无法精确表达像 $\\frac{1}{3}$ 和 $\\frac{5}{7}$ 这样的数。类似，二进制小数也只能表示那些能够被写成 $x*2^y$ （其中 $x,y$ 是整数）的数。其他的值都只能近似地表示。增加位长可以提高精度。 IEEE 浮点上面提到的定点表示法不能很有效地表示非常大的数字。例如，表达式 $5×2^{100}$ 是用 $101$ 后面跟随 $100$ 个零的位模式来表示的。相反，我们希望通过给定 $x,y$ 来表示形如 $x×2^y$。 IEEE 浮点标准用 $V=(-1)^s×M×2^E$ 的形式来表示一个数： 符号（sign）：$s$ 决定这个数是负数（$s=-1$) 还是正数（$s=0$），而对于数值 $0.0$ 的符号位解释为特殊情况处理。 尾数（significand）：$M$ 是一个二进制小数，它的范围是 1 ~ 2 - $\\epsilon$，或者是 0 ~ 1 - $\\epsilon$。 阶码（exponent）：$E$ 的作用是对浮点数加权，实际上就是在表示小数点的位置，也就是“浮点”。 给定位表示，根据 exp 的值，被编码的值可以分成三种不同的情况。 情况 1：规格化的值（Normalized value）这是最普遍的情况，当 exp 的位模式既不全为 0（数值 0），也不全为 1 （对于单精度浮点数 float，数值为 255）时，都属于这类情况。 在这种情况中，阶码 exp 字段被解释为以偏置（biased）形式表示的有符号整数。也就是说，阶码的值是 $E=e-Bias$。其中 $Bias$ 是一个等于 $2^{k-1}-1$ 的偏置量，对于单精度浮点数是 127，而双精度是 1023。 小数字段 $frac$ 被解释为描述二进制小数值 $f$，由于二进制表示的最高位肯定是 1（implied leading 1），我们就不必对这个最高位进行编码，这样的处理获得了一个额外精度位。 情况 2：非规格化的值（Denormalized value）当阶码域全为 0 的时候，所表示的数是非规格化的。在这种情况下，阶码值是 $E=1-Bias$，而尾数的值是 $M=f$，也就是直接编码，不再包含隐含的开头的 1。 非规格化的数可以用来表示很接近零的数，由于所有的非规格数的阶码值都是一样的，所以它们在零的附近分布是完全均匀的的，即：相邻的两个非规格化浮点数之间的距离都是一致的。 此外，考虑从最大的非规格数到最小的规格数的“过渡过程“，将阶码值设置为 $1-Bias$ 提供了一种平滑的方式过渡。 情况 3：特殊值最后一类数值是当阶码全为 1 的时候出现的。 当小数域全为零，得到的值表示无穷，当 $s=0$ 时是 $+\\infty$，当 $s=1$ 时是 $-\\infty$。当我们把两个非常大的数相乘，或者除以非常小的数的时候，无穷可以表示浮点溢出的结果。 当小数域非零时，结果数值被称为 $NaN$，即”不是一个数字“（Not a Number）的缩写。一些运算的结果不能是实数或无穷，就会返回这样的 $NaN$ 值，比如当计算 $\\sqrt{-1}$ 或 $\\infty-\\infty$ 时。 上图是一个典型情况，规范型浮点数。 浮点数的“值域” 我们直观地看到，浮点数在原点的附近分布密集，远离原点的地方分布稀疏。事实上，这是由于在不同阶码下，$frac$ 区域加 1 变化的值不同而导致的。 浮点运算律与类型转换 int ，float，double 之间进行的类型转换改变位表示。 float，double 到 int 的转换截断小数部分，类似于“向 0 舍入”。 int → double 的转换是精确的，这是由于 double 有 53 个 $frac$ 位。 int → float 的转换可能是不精确的，需要舍入，这是由于 float 只有 23 个$frac$ 位。 浮点运算不是结合的，也不是交换的，采用从左到右的方式计算表达式，考虑这个例子： 12float a = 3.14 + 1e20 - 1e20; // a = 0.0f, roundingfloat b = 3.14 + (1e20 - 1e20); // b = 3.14f","link":"/2020/01/22/CSAPP%20I/"},{"title":"UniqueLab 春令营的面试总结","text":"&emsp;&emsp;春季学期报名了联创 lab 组，这次因为情况特殊，没有笔试环节，一上来就是面试，大概把面试的流程记录一下，后面再去学习总结。 第一部分：C 语言的特性 Q：你了解函数指针吗，函数指针有什么作用？ 一上来这个题目比较友好，算是让选手进入状态吧，还算顺利地回答上来了，函数指针这个思想在 C 族语言中基本都有保留（别的语言也不太了解），我的话主要是在 C # 里面的委托里面尝试过“函数指针”的用法，但是因为平常干活的时候还是很少，不是能说很熟悉。 Q：请声明一个函数指针，对某个签名为 char* func (int a, char b); 的函数。 果然这个地方就犯怵了，在 C 中，没有用过几次，也是照着写的，我的回答是： (char *)(int, char) ptr; 后面再看这个答案，错的还是挺多的，比如变量名字应该写在中间（就像一个函数声明一样），然后在变量名前面加一个 star，即：char *(*ptr)(int, char); 这里还有一个细节，括号是必不可少的，原因也是避免二义性之类的问题。 这个地方没有答好，写的时候也说明了情况，不过面试的学长说问题不太大，也确实大概如此，用到的时候可以再翻手册，不过这种基础还是要掌握了比较好，后面要牢牢记住。 Q：你用过宏吗？ 用过， OI 里面的一些简写法，比如求最大最小值，for 循环的快速写法等等…我还又把自己了解的一些预编译指令，防止库重复引用啥的，都说了说… Q：请你写一个带参数的宏，求两个数的最大值。 这块正好是熟悉的啊，然后我的回答是.. #MAX(a, b) ((a) &gt; (b) ? (a) : (b)) ……. 也挺无语的了，愣是能把 define 给忘记了，倒是还记着，参数和表达式整体都要带上括号，因为毕竟宏的处理是在编译时（如果狭义的编译的话，那就是前），参数和表达式的替换都是直接进行的，不会把整体拿出来，如果不加括号可能会出奇怪的锅… 这个问题反映出来的也是，在面试这种相对高压力的环境下，有些即使你很清楚的东西，自认为不会犯的错误也是会经常出现的，要想提高面试水平，除了提高心理素质，还得再次打牢基础。 后面好像答到两题后的时候，突然想起来了 define，又和学长说了一下，学长又说问题不大… Q：请你说一下 static 和 extern 两个关键字的作用。 这块正好是 2 月份看 CS：APP 中“链接“那一章中讲到的，之前的话由于写的 C / C++程序都是算法程序，一次性代码，一个文件就弄完，没有怎么了解过库的编写，库的引用这些东西。不过还好是学了，了解了这两个关键字，顺利地回答了上来。 Q：对于static int a = 1，这个变量的内存是什么时候分配的？ 这里学长问了两种情况，第一种，语句在函数外部的时候；第二种，语句在某个函数内部的时候。 其实对于这两种情况，答案是一样的，在编译的过程中，链接器主要干两件事： Symbol Resolution，把各类的函数，（全局）变量的声明解析出来； Relocation，把每一个 Symbol 对应到它的内存地址，这句话是从编译的角度讲的，从内存分配的角度说，也自然是分配了内存。 对于 Symbol 来说，分为强和弱两种，链接器不允许出现多个同名的强 Symbol。 直接初始化的函数和变量都被认为是强的，反之是弱的；如果出现一强多弱的情况，链接器会在 Relocation 的过程中把每个引用到这个 Symbol 的地方给到强变量的地址；如果出现无强多弱的情况，编译器会随意地选择一个，这往往会带来非常难以排查的错误。 于是，这个问题解决了，不过上面提到的两种情况的区别是，当把静态变量声明到函数体内的时候，这个变量的作用域仍然还是它本应有的，不允许在外部使用。 Q：请谈一下 new 和 malloc 的区别。 面试的时候，还不知道 new 这个关键字是 C++ 特有的，这块的内容也是有一点模糊，不能说懂得很详细。 把自己知道的都讲了讲，大概说了这么几点吧： 二者都是动态分配内存的，在销毁的时候需要手动 delete / free 掉这部分内存，不然会内存泄漏； malloc 分配到的内存没有初始化，不保证全 0 等等； 分配的内存都是在堆上的，如果而且这个过程存在 fail 掉的可能，比如内存不足的情况； 除此之外，后面学习到的还有： malloc 的返回值是 void * 类型的，手动使用的时候需要自己强制类型转换成自己需要的（这一点其实我是知道的，但是没说上来） new 的返回值是指定类型的指针，可以自动计算需要的空间大小（同上） new 的实现是用 malloc 来做的 Q：了解过 C 语言函数调用的约定吗？ ”是 caller-save 和 callee-save 吗“ ”不是“ ”那就不太了解了…“ 学长给出了 ”__cdecl“作为例子，后面去查了一下，大概学习了一哈。 调用约定(Calling convention)，它决定以下内容：1)函数参数的压栈顺序； 2)由调用者还是被调用者把参数弹出栈； 3)以及产生函数修饰名的方法。 大概就是调用者与被调用者之间保持的约定，用来协调参数传递，控制交接这些内容的。 Q：用过可变参数个数的函数吗，写过吗？ 用当然是用过，比如 scanf，printf，这一类的，但是没有写过。 在后面的学习中，了解到，其实就是上面这种调用者与被调用者对于参数的这种约定实现了可变参数个数。 这一部分内容比较底层， 有空去再去了解一下语言的这些机制。 第二部分：算法 Q：先上来的就是一道数据结构题目。 由于是英文题面，读题费了稍微长一点的时间… 读完了大概，知道这肯定是一道线段树的题目…但是还是没有太好的想法，但其实面试之后发现，每次区间乘法，题目保证的 $x$ 的取值是不超过 10 的，这一下子让这个题目变得比较明朗了。 对于 10 以内的数，总共有 2，3，5，7，四个素数，建立四棵线段树，分别维护区间中这四个因子的指数，每次乘法，把它分解一下，然后在对应的树上做区间加法，就可以了；而对于查询，其实也就是四棵树上的区间内的最大值。 但是….面试的时候没有注意到这个不超过 10 的这个数据范围，最终没有完整答上来，只说到了线段树..还是没有做好这题.. Q：给一个二叉树的根，写一个小的函数，求所有节点中的最大值。 白板代码题，在记事本里面大概写了一个递归的做法，说了一下这样做只求一次的复杂度是 $O(N)$ 的，但是多次求的话，后面的复杂度不会降，大概就是这样。 还用了我上面写的求 MAX 的宏，完成的没有什么大问题，还算比较顺利。 第三部分：Linux 与 操作系统 Q：有没有用过 Linux，会不会 / 会多少 Linux 的命令？ 因为平常做 CMU / UCB 的 lab 作业、包括各类工具基本就要用 Linux，上个学期在这块还是花了不少功夫在学习，对于命令的话，基本的操作都没啥问题，比较进阶的掌握的要少一点。 Q：了解 Linux 的权限系统吗，权限分别是对哪三类人来说的？ 了解。分别是：文件的所有者，工作组的人，以及其它所有人。 Q：为什么服务器上主要是 Linux？ 这个问题的话，也就是把自己知道的都大概讲了讲： 命令行操作，方便，开销低； 对 C 语言、网络库等全面、完善的支持； 开源社区，系统可拓展性、灵活性强； 安全性强，稳定 Q：你知道什么是僵尸进程，孤儿进程吗？ 这个真不知道，操作系统还没有学，后面再去了解吧。 第四部分：网络 Q：TCP 协议是几次握手？ 三次握手，四次挥手，但是当时大概就了解了这么多，也是类似于科普性质的知道。 这次实习任务之后，又对这些网络协议有了更深入的理解，包括 ”连接“ seq / ack 机制 丢包、重发、阻塞 因为说了懂的有限，学长们在网络这个部分也没法再问了…（太菜了…），于是，这次面试就这样结束了。 后面还要继续学习，拓展知识边界。 题外： 大概就这样啦，今天刚刚结束了 12 天的实习任务。 即将迎来 hackweek，希望能再做一点漂亮的工作，争取加入团队吧！ 和大佬们差距还是很大，要保持一直学习的态度呀 加油 zhuo1ang","link":"/2020/03/14/UniqueLab%20%E6%98%A5%E4%BB%A4%E8%90%A5%E7%9A%84%E9%9D%A2%E8%AF%95/"},{"title":"我崎岖的 Vim 学习之路","text":"&emsp;&emsp;今天又学到了一个技巧，解决了真实的问题。这也让我激起了深深的回想，研究 Vim 的过程中曲折的学习之路，这里也做个总结，记录一下。 &emsp;&emsp;事情是这样的，去年来上学开始，就一直有了要用 Linux 的需求，不管是做 15-213、 61-A 的 lab，还是说什么其它的学习要求，这都成为了一个问题。 &emsp;&emsp;最开始的时候，我尝试了安装虚拟机，当时甚至可以说是我第一次尝试虚拟机的操作。在 OI 时期，Barty 曾经建议我装一下 NOI Linux，（后面知道了这个就是一个魔改的 Ubuntu），不过当时好像在安装的过程中出现了奇怪的报错，也始终不会解决，最终就不了了之了。这也是我一直以来特别讨厌、痛恨、害怕各种报错的原因。 &emsp;&emsp;当时按照 《鸟哥的 Linux 私房菜》 这本书上面讲的来，于是就装了 CentOS，又因为这个感觉 CentOS 的 UI 有点丑，于是又同时装了 Ubuntu，用着用着就基本全去搞 Ubuntu 了… &emsp;&emsp;装了虚拟机，当时最主要的目的就是两个，一个是学习 Linux 系统，另一个是做各种 lab。在这个新环境下，总得开始配个开发环境。然而 15-213 的课程前几个 lab，都不是“传统意义上的 Coding”要求很高的任务，于是我就这么一直凑活，用着 gedit 这个还算图形化的编辑器一直搞，如果要在终端里面敲的话就用一下 nano，日子也就这么一天一天地过，虽然似乎 nano 这个编辑器在鄙视链的最底端，但是当我知道 nano 也是 GNU 计划的一部分的时候，那一瞬间我仿佛就变得不那么 low 了。 &emsp;&emsp;当时的心态大概是这个样子，当然当时也知道 Vim，Emacs 的圣战之类的，也是感觉熟练地用 Vim 在代码里面上下飞确实是一件很帅的事情…不过一直都感觉上手难度太大，也没有特别大的动力、需求去费劲把它搞明白，在这个阶段，大概只是知道 Vim 的几个模式，保存、退出等等… &emsp;&emsp;然后一件有点让人恼火的发生了，在我搞完 Data lab 之后，其中最后一个函数 始终跑不过，显示的一直是超时，10 秒钟的时间都跑不完一个单元测试，总是让我怀疑是不是哪里写错了。但是这么简单几行一个函数，又能有啥问题，折腾了很久也没有办法跑过。这件事后面成为了我装 Ubuntu 物理机的一个直接动机。当然，后面把这个问题查清楚了，确实就是虚拟机性能太低，即使在外面把计算性能调到最高，还是不能跑过；而当时也不懂 lab 里面做测试的程序的原理，其实那个程序都是自己 make 出来的， source 都可以自己改，在虚拟机里面，把 timeout 改成 30s，很顺利地就跑过去了。 &emsp;&emsp;总之，因为在虚拟机里面操作各种的不方便，不舒服，再加上自己想尝试完全地用 Linux 来工作，杜绝 Windows 打游戏摸鱼。于是就搞了个镜像直接装了 Ubuntu 18.04 的真实机。刚刚折腾过去之后，最大的感受就是爽，虽然本身机器配置不差，但是在 Linux 下面还是明显地感觉到机器非常舒服，平时风扇的声音小了好多。除此之外，配置了各种 VS Code，Chrome，Typora，代理服务器，网易云，在 Linux 下面的开发非常舒服。就这样搞了三个月，平常只有必须到桌面端上网课的时候才搞到 Windows，同时又因为没有配置 Win 的环境，上去如果要进行一些进阶操作，每次都是对 Win 骂骂咧咧的… &emsp;&emsp;物理机这块似乎跑了一点题，重点应该是 Vim 来着。不过没有办法，在 Ubuntu 图形界面里面，用 VS Code 确实还是太舒服了，虽然在这个过程中我也跟着一些教程学了一些 Vim 快捷键，但是距离“在代码中飞行”的水平还差的太远，而且 VS Code 这种现代编辑器的代码补全、快速重构、调试，等等的功能还是用起来体验太好。说到这…虽然我也不是特别清楚，不过我估计在 Vim 上面应该也有各种各样的插件支持上面说的这些操作，Vim 的死忠们估计完全不会认同我说的…但是 Text Editor 这个事情毕竟还是非常主观，差异非常大的，对于我这种非常懒又很小白的用户，有现成能用的就不愿意花太多时间在工具的学习上面。 &emsp;&emsp;到这个阶段，不得不用 Vim 的情景大概就只有远程连接服务器操作的时候了，不过对这个问题我的 Solution 是…先在本地 VS Code 搞，然后再右键上去…如果遇到了环境依赖问题，不得已的时候再用 Vim 做一些小的问题修改。就这样凑合着整，倒也还算是不错。 &emsp;&emsp;接下来又是一件奇怪的事情了。由于一直在用 Ubuntu，就没有在 Windows 下面搞 shadowsocks 的客户端，科学上网的问题还没解决，这时候就碰到了诡异的问题，设置里面的代理信息无法保存。 &emsp;&emsp;但是参考了各种各样的攻略，包括微软论坛上工程师的详细解答，始终还是不能解决，这件事就被拖了一段时间。就在前几天，突然想起来自己的 Windows 的版本竟然才是 1809，再加上又最近又爆出什么安全漏洞的事情（也没有仔细看，好像是一个收包检测的过程没有 Check，可能导致 Code Injection，搞出蠕虫来），正好可以升级更新一下。这个更新的过程，也是异常地曲折困难，又是报的错参考了微软论坛的方案也不能解决，最终折腾了好久终于弄上了 1909 的版本。然后转念又一想，既然都已经升了，马上新的 2004 就要变正式版，干脆直接整上吧，据说这个现在 3 月的这个已经非常稳定，和正式版本差别不大，一次给它安排了，一年以内不用再操心了。 &emsp;&emsp;就这样，我兴高采烈地安排上了 Windows 10 2004，同时，在更新日志里面，又注意到了新版的 WSL 2。于是在微软商店里面搞了一个 Ubuntu 18.04 LTS，尝试了一下，发现这个速度比虚拟机里面的系统快多了，毕竟微软的这个虚拟技术和 VM 的不太一样，层级上来讲可以说和本身的 Windows 平行，确实快了很多，舒服了不少。搞到这里，我对 Win 就已经有一些好感了，也逐渐能理解“最好的 Linux 发行版就是 Windows”这个意思了。 &emsp;&emsp;到这里，用 WSL 2 就可以得到一个命令行的 Linux，SSH 也能操作云服务器；后面试了试代理的设置，更新过后直接就好了，这样科学上网的问题也解决了。而桌面端的 Windows 还是可以全部使用 VS Code，云服务器上使用 Vim，就能解决全部的需求。 &emsp;&emsp;然而就在一天之后的昨天…我又了解到了 VS Code 的远程资源管理的新功能… &emsp;&emsp;安装过 VS Code 新插件之后，可以直接在这里面打开 WSL 的机器，SSH 连接的远程主机，所有内容一样都在这里面打开，日常的开发工作简直完美啊！不过，又去了解了一番原理之后，发现，这个 WSL 2 的问题大概是以下几点： WSL 2 是基于 Hyper-V 的，跑了一个WSL2之后，就没法启动 VirtualBox 了 在连接 Shadowsocks 的情况下，WSL 2 内无法访问外网 IPv6 （不过我目前、可预见的未来没有这个需求 不支持 GPU &emsp;&emsp;不过从我目前的需求来看，这个方案已经完美地解决了我的问题了，而 Vim，这篇文章的主角，暂时性地也失去了它的位置…看起来目前所有的场景，都不太需要它的出现了。 &emsp;&emsp;不过目前所有命令行内的文本编辑工作，也算是全部交给 Vim 了，虽然不是一个主力，不过我想慢慢地去磨这个熟练 Vim 的进度，估计等到我走到工作岗位的时候，也可以算是高手了 hhh","link":"/2020/03/18/%E6%88%91%E5%B4%8E%E5%B2%96%E7%9A%84%20Vim%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"CS:APP","slug":"CS-APP","link":"/tags/CS-APP/"},{"name":"汇编语言","slug":"汇编语言","link":"/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"编译","slug":"编译","link":"/tags/%E7%BC%96%E8%AF%91/"},{"name":"哲学","slug":"哲学","link":"/tags/%E5%93%B2%E5%AD%A6/"},{"name":"翻译","slug":"翻译","link":"/tags/%E7%BF%BB%E8%AF%91/"},{"name":"联创","slug":"联创","link":"/tags/%E8%81%94%E5%88%9B/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"Vim","slug":"Vim","link":"/tags/Vim/"},{"name":"VS Code","slug":"VS-Code","link":"/tags/VS-Code/"},{"name":"编辑器","slug":"编辑器","link":"/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"}],"categories":[{"name":"计算机科学","slug":"计算机科学","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"杂篇","slug":"杂篇","link":"/categories/%E6%9D%82%E7%AF%87/"},{"name":"想法","slug":"想法","link":"/categories/%E6%83%B3%E6%B3%95/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"}]}